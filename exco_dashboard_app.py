#!/usr/bin/env python3
"""
Streamlit dashboard for Executive Committee (EXCO) recommendation oversight.

The application reads the Excel workbook generated by `process_exco_report.py`
and presents a board-ready experience with interactive filters, KPI tiles,
visual summaries, persona-focused views, and downloadable extracts.

Run locally with:
    streamlit run /Users/satyasagardandela/Downloads/monthly\\ Reporting/exco_dashboard_app.py
"""

from __future__ import annotations

from datetime import date, datetime
from functools import lru_cache
from pathlib import Path
from typing import Dict, List, Optional, Sequence, Tuple

import numpy as np
import pandas as pd
import plotly.express as px
import streamlit as st

st.set_page_config(
    page_title="EXCO Recommendation Dashboard",
    page_icon="üìä",
    layout="wide",
    menu_items={
        "About": "Executive dashboard for EXCO recommendation tracking. "
        "Built with Streamlit and Plotly.",
    },
)


DATA_FILE = Path("/Users/satyasagardandela/Downloads/monthly Reporting/EXCO_Report_Output.xlsx")
PRIMARY_SHEET = "ECAG open Recos"
BOARD_FLAG_COLUMNS: Dict[str, str] = {
    "M. Graulich": "M. Graulich",
    "D. Senko": "D. Senko",
    "J. Janka": "J. Janka",
    "M. Matusza": "M. Matusza",
}
BOARD_MEMBERS: List[str] = list(BOARD_FLAG_COLUMNS.keys())
DATE_COLUMNS = ["Issue Date", "Initial Deadline", "Current Deadline"]
STATUS_OPEN_VALUES = {"Open", "In Progress", "Overdue", "Notes"}

# Apply a consistent light Plotly theme
px.defaults.template = "plotly_white"
CUSTOM_COLORWAY = ["#f97316", "#60a5fa", "#facc15", "#34d399", "#a855f7", "#ec4899"]


@st.cache_data(show_spinner="Loading dashboard data‚Ä¶")
def load_sheet(sheet_name: str) -> pd.DataFrame:
    if not DATA_FILE.exists():
        raise FileNotFoundError(
            f"Could not locate EXCO report output at {DATA_FILE}. "
            "Please run process_exco_report.py to generate the file first."
        )

    df = pd.read_excel(DATA_FILE, sheet_name=sheet_name, engine="openpyxl")
    df = df.replace({"Yes": "Yes", "No": "No"}).fillna(value=np.nan)

    for col in DATE_COLUMNS:
        if col in df.columns:
            df[col] = pd.to_datetime(df[col], errors="coerce")

    if "Current Deadline" in df.columns:
        today = pd.Timestamp(datetime.today().date())
        df["Days to Deadline"] = (df["Current Deadline"] - today).dt.days
        df["Is Overdue"] = df["Current Deadline"].notna() & (df["Current Deadline"] <= today)
        df["Due in 30 Days"] = (
            df["Current Deadline"].notna()
            & (df["Current Deadline"] >= today)
            & (df["Current Deadline"] <= today + pd.Timedelta(days=30))
        )
    else:
        df["Days to Deadline"] = np.nan
        df["Is Overdue"] = False
        df["Due in 30 Days"] = False

    if "Recommendation Status" in df.columns:
        df["Recommendation Status"] = df["Recommendation Status"].str.strip()
    if "Severity" in df.columns:
        severity_order = pd.CategoricalDtype(categories=["S4", "S3", "S2", "S1"], ordered=True)
        df["Severity"] = df["Severity"].astype(severity_order)

    return df


@lru_cache(maxsize=1)
def get_available_sheets() -> List[str]:
    if not DATA_FILE.exists():
        return []
    xls = pd.ExcelFile(DATA_FILE, engine="openpyxl")
    return xls.sheet_names


def apply_filters(
    df: pd.DataFrame,
    board_selection: Sequence[str],
    severities: Sequence[str],
    statuses: Sequence[str],
    legal_entities: Sequence[str],
    include_overdue_only: bool,
    include_due_soon_only: bool,
    deadline_window: Optional[Tuple[date, date]],
    search_text: str,
) -> pd.DataFrame:
    filtered = df.copy()

    if board_selection:
        mask = pd.Series(False, index=filtered.index)
        for board_member in board_selection:
            col = BOARD_FLAG_COLUMNS.get(board_member)
            if col and col in filtered.columns:
                mask |= filtered[col].astype(str).str.upper().eq("YES")
            elif "Board member" in filtered.columns:
                mask |= filtered["Board member"].astype(str).str.contains(board_member, case=False, na=False)
        filtered = filtered[mask]

    if severities:
        filtered = filtered[filtered["Severity"].isin(severities)]

    if statuses:
        filtered = filtered[filtered["Recommendation Status"].isin(statuses)]

    if legal_entities:
        if "Relevant Legal Entities" in filtered.columns:
            mask = filtered["Relevant Legal Entities"].astype(str).str.upper().apply(
                lambda cell: any(entity.upper() in cell for entity in legal_entities)
            )
            filtered = filtered[mask]

    if include_overdue_only:
        filtered = filtered[filtered["Is Overdue"]]

    if include_due_soon_only:
        filtered = filtered[filtered["Due in 30 Days"]]

    if deadline_window and "Current Deadline" in filtered.columns:
        start, end = deadline_window
        mask = filtered["Current Deadline"].between(pd.Timestamp(start), pd.Timestamp(end), inclusive="both")
        filtered = filtered[mask]

    if search_text:
        like = search_text.strip().lower()
        searchable_cols = [
            col
            for col in ["Finding ID", "Recommendation ID", "Finding Title", "Recommendation Details", "Management Response"]
            if col in filtered.columns
        ]
        if searchable_cols:
            text_mask = pd.Series(False, index=filtered.index)
            for col in searchable_cols:
                text_mask |= filtered[col].astype(str).str.lower().str.contains(like, na=False)
            filtered = filtered[text_mask]

    return filtered


def get_board_slice(df: pd.DataFrame, board_member: str) -> pd.DataFrame:
    """Return the subset of rows assigned to a given board member."""
    flag_col = BOARD_FLAG_COLUMNS.get(board_member)
    if flag_col and flag_col in df.columns:
        mask = df[flag_col].astype(str).str.upper() == "YES"
        return df[mask]

    if "Board member" in df.columns:
        mask = df["Board member"].astype(str).str.contains(board_member, case=False, na=False)
        return df[mask]

    return df.iloc[0:0]


def apply_global_styles() -> None:
    """Inject global CSS to deliver a polished executive look and feel."""

    st.markdown(
        """
        <style>
            [data-testid="stAppViewContainer"] {
                background: linear-gradient(180deg, #f8fafc 0%, #eef2ff 48%, #e0e7ff 100%);
                color: #0f172a;
                padding-top: 1rem;
            }
            [data-testid="stAppViewContainer"] h1,
            [data-testid="stAppViewContainer"] h2,
            [data-testid="stAppViewContainer"] h3,
            [data-testid="stAppViewContainer"] h4,
            [data-testid="stAppViewContainer"] h5,
            [data-testid="stAppViewContainer"] h6,
            [data-testid="stAppViewContainer"] p,
            [data-testid="stAppViewContainer"] span,
            [data-testid="stAppViewContainer"] li {
                color: #0f172a !important;
            }
            [data-testid="stSidebar"] {
                background: #0f172a;
                color: #e2e8f0;
                border-right: 1px solid rgba(148, 163, 184, 0.25);
                padding-top: 1rem;
            }
            [data-testid="stSidebar"] h1,
            [data-testid="stSidebar"] h2,
            [data-testid="stSidebar"] h3,
            [data-testid="stSidebar"] p,
            [data-testid="stSidebar"] span,
            [data-testid="stSidebar"] label {
                color: #e2e8f0 !important;
            }
            .stSidebar [data-testid="stMarkdownContainer"] h1,
            .stSidebar [data-testid="stMarkdownContainer"] h2,
            .stSidebar [data-testid="stMarkdownContainer"] h3 {
                color: #e0e7ff;
            }
            .stSidebar input,
            .stSidebar select,
            .stSidebar textarea {
                background-color: rgba(30, 41, 59, 0.65);
                color: #f8fafc !important;
                border-radius: 0.5rem;
            }
            .stTabs [role="tablist"] {
                gap: 0.45rem;
                margin-bottom: 1rem;
            }
            .stTabs [role="tab"] {
                background: rgba(226, 232, 240, 0.8);
                color: #0f172a;
                border-radius: 999px;
                padding: 0.5rem 1.2rem;
                border: 1px solid transparent;
                transition: all 0.3s ease;
                font-weight: 500;
            }
            .stTabs [role="tab"][aria-selected="true"] {
                background: #ffffff;
                border-color: rgba(79, 70, 229, 0.25);
                color: #0f172a;
                box-shadow: 0 12px 26px rgba(15, 23, 42, 0.12);
            }
            .stTabs [role="tab"]:hover {
                color: #0f172a;
            }
            .kpi-card {
                background: #ffffff;
                color: #0f172a;
                padding: 1.25rem 1.5rem;
                border-radius: 1rem;
                border: 1px solid rgba(15, 23, 42, 0.1);
                box-shadow: 0 16px 32px rgba(15, 23, 42, 0.08);
                min-height: 120px;
            }
            .kpi-card--amber::before,
            .kpi-card--rose::before,
            .kpi-card--emerald::before {
                content: "";
                display: block;
                height: 4px;
                border-radius: 999px;
                margin-bottom: 1rem;
            }
            .kpi-card--amber::before { background: linear-gradient(90deg, #f59e0b, #d97706); }
            .kpi-card--rose::before { background: linear-gradient(90deg, #ef4444, #b91c1c); }
            .kpi-card--emerald::before { background: linear-gradient(90deg, #10b981, #059669); }
            .kpi-card__label {
                font-size: 0.95rem;
                text-transform: uppercase;
                letter-spacing: 0.12em;
                opacity: 0.75;
            }
            .kpi-card__value {
                font-size: 2.2rem;
                font-weight: 600;
                margin-top: 0.35rem;
            }
            section[data-testid="stSidebar"] .streamlit-expanderHeader {
                font-weight: 600;
                letter-spacing: 0.05em;
            }
            div[data-testid="stMetricLabel"] {
                color: #0f172a !important;
                font-weight: 500;
            }
            div[data-testid="stMetricValue"] {
                color: #0f172a !important;
            }
        </style>
        """,
        unsafe_allow_html=True,
    )


def derive_last_refresh(df: pd.DataFrame) -> Optional[pd.Timestamp]:
    """Return the most recent timestamp across recognised date columns."""

    date_series: List[pd.Series] = []
    for column in df.columns:
        if "date" in column.lower() and pd.api.types.is_datetime64_any_dtype(df[column]):
            date_series.append(df[column])

    # Always consider the canonical date fields if available
    for column in DATE_COLUMNS:
        if column in df.columns and pd.api.types.is_datetime64_any_dtype(df[column]):
            date_series.append(df[column])

    if not date_series:
        return None

    combined = pd.concat(date_series, axis=0).dropna()
    if combined.empty:
        return None
    return combined.max()


def render_header(df: pd.DataFrame, selected_sheet: str) -> None:
    """Display the hero header with title, context, and refresh timestamp."""

    last_refresh = derive_last_refresh(df)
    refresh_text = last_refresh.strftime("%d %b %Y") if last_refresh else datetime.today().strftime("%d %b %Y")

    st.markdown(
        f"""
        <div style="background: linear-gradient(130deg, #e0e7ff, #c7d2fe); padding: 1.8rem 2.2rem; border-radius: 1.2rem; margin-bottom: 1.2rem; box-shadow: 0 22px 45px rgba(79, 70, 229, 0.18); color: #0f172a;">
            <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 2rem; flex-wrap: wrap;">
                <div style="flex: 1 1 60%; min-width: 240px;">
                    <h1 style="margin: 0; font-size: 2.4rem; font-weight: 600; color: #0f172a;">EXCO Recommendation Dashboard</h1>
                    <p style="margin: 0.75rem 0 0; font-size: 1.05rem; opacity: 0.88; color: #1f2937;">
                        A consolidated view of open recommendations, ownership, and delivery risk to support the Executive Board's oversight and decision making.
                    </p>
                    <p style="margin: 0.6rem 0 0; font-size: 0.95rem; opacity: 0.78; color: #1f2937;">Active sheet: <strong>{selected_sheet}</strong></p>
                </div>
                <div style="flex: 0 0 auto; background: rgba(79, 70, 229, 0.15); padding: 1rem 1.4rem; border-radius: 0.9rem; text-align: right; color: #1f2937;">
                    <div style="font-size: 0.85rem; letter-spacing: 0.1em; text-transform: uppercase; opacity: 0.7;">Last refreshed</div>
                    <div style="font-size: 1.6rem; font-weight: 600;">{refresh_text}</div>
                </div>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )


def render_kpis(df: pd.DataFrame) -> None:
    """Display a row of key performance indicator cards for executive review."""

    total = int(len(df))
    status_series = df["Recommendation Status"] if "Recommendation Status" in df.columns else pd.Series(dtype=str)
    open_count = int(status_series.isin(STATUS_OPEN_VALUES).sum()) if not status_series.empty else 0

    overdue_mask = pd.Series(False, index=df.index)
    if "Is Overdue" in df.columns:
        overdue_mask |= df["Is Overdue"].fillna(False)
    if not status_series.empty:
        overdue_mask |= status_series.astype(str).str.contains("overdue", case=False, na=False)
    overdue = int(overdue_mask.sum())

    due_soon = int(df["Due in 30 Days"].sum()) if "Due in 30 Days" in df.columns else 0

    columns = st.columns(4)
    metrics = [
        ("üìå Total Recommendations", total, "kpi-card"),
        ("üóÇÔ∏è Active / Open", open_count, "kpi-card kpi-card--amber"),
        ("‚è∞ Overdue", overdue, "kpi-card kpi-card--rose"),
        ("üìÖ Due in 30 Days", due_soon, "kpi-card kpi-card--emerald"),
    ]

    for col, (label, value, css_class) in zip(columns, metrics):
        with col:
            st.markdown(
                f"""
                <div class="{css_class}">
                    <div class="kpi-card__label">{label}</div>
                    <div class="kpi-card__value">{value:,}</div>
                </div>
                """,
                unsafe_allow_html=True,
            )

    st.markdown(
        "<p style='color: #0f172a; font-size: 0.9rem; margin-top: 0.75rem;'>"
        "Overdue items include any recommendation past its current deadline or explicitly marked as overdue in the status."
        "</p>",
        unsafe_allow_html=True,
    )


def render_distribution_charts(df: pd.DataFrame) -> None:
    col1, col2 = st.columns(2)

    with col1:
        if "Severity" in df.columns and not df["Severity"].dropna().empty:
            severity_counts = (
                df["Severity"]
                .value_counts(dropna=False)
                .rename_axis("Severity")
                .reset_index(name="count")
                .sort_values("Severity")
            )
            fig_severity = px.pie(
                severity_counts,
                names="Severity",
                values="count",
                title="Distribution by Severity",
                color="Severity",
                color_discrete_map={
                    "S4": "#ef4444",
                    "S3": "#f59e0b",
                    "S2": "#facc15",
                    "S1": "#22c55e",
                },
            )
            fig_severity.update_traces(textposition="inside", textinfo="label+percent")
            fig_severity.update_traces(textfont=dict(color="#0f172a"))
            fig_severity.update_layout(
                margin=dict(t=50, r=20, b=10, l=10),
                paper_bgcolor="rgba(0,0,0,0)",
                plot_bgcolor="rgba(0,0,0,0)",
                font=dict(color="#0f172a"),
                title=dict(font=dict(color="#0f172a", size=18)),
                showlegend=False,
            )
            st.plotly_chart(fig_severity, use_container_width=True)
        else:
            st.info("Severity data not available for this sheet.")

    with col2:
        if "Recommendation Status" in df.columns and not df["Recommendation Status"].dropna().empty:
            status_counts = (
                df["Recommendation Status"]
                .value_counts(dropna=False)
                .rename_axis("Recommendation Status")
                .reset_index(name="count")
                .sort_values("count", ascending=False)
            )
            fig_status = px.bar(
                status_counts,
                x="Recommendation Status",
                y="count",
                title="Status Breakdown",
                text_auto=True,
                color="Recommendation Status",
                color_discrete_sequence=CUSTOM_COLORWAY,
            )
            fig_status.update_traces(textfont=dict(color="#0f172a"))
            fig_status.update_layout(
                margin=dict(t=50, r=20, b=60, l=10),
                paper_bgcolor="rgba(0,0,0,0)",
                plot_bgcolor="rgba(0,0,0,0)",
                font=dict(color="#0f172a"),
                hovermode="x unified",
                title=dict(font=dict(color="#0f172a", size=18)),
            )
            fig_status.update_xaxes(title_text="Recommendation Status", tickfont=dict(color="#0f172a"))
            fig_status.update_yaxes(title_text="Count", tickfont=dict(color="#0f172a"))
            st.plotly_chart(fig_status, use_container_width=True, theme=None)
        else:
            st.info("Status data not available for this sheet.")

    if "Current Deadline" in df.columns and df["Current Deadline"].notna().any():
        deadlines = df.dropna(subset=["Current Deadline"]).copy()
        deadlines["Current Deadline"] = deadlines["Current Deadline"].dt.normalize()
        deadlines["Deadline Month"] = deadlines["Current Deadline"].dt.to_period("M").dt.to_timestamp()
        pipeline = (
            deadlines.groupby("Deadline Month").size().rename("count").reset_index().sort_values("Deadline Month")
        )
        fig_deadline = px.bar(
            pipeline,
            x="Deadline Month",
            y="count",
            title="Pipeline by Deadline Month",
            text_auto=True,
            color="count",
            color_continuous_scale=["#2563eb", "#7c3aed"],
        )
        fig_deadline.update_traces(textfont=dict(color="#0f172a"))
        fig_deadline.update_layout(
            margin=dict(t=50, r=20, b=60, l=10),
            paper_bgcolor="rgba(0,0,0,0)",
            plot_bgcolor="rgba(0,0,0,0)",
            font=dict(color="#0f172a"),
            title=dict(font=dict(color="#0f172a", size=18)),
        )
        fig_deadline.update_xaxes(title_text="Deadline Month", tickfont=dict(color="#0f172a"))
        fig_deadline.update_yaxes(title_text="Recommendations", tickfont=dict(color="#0f172a"))
        st.plotly_chart(fig_deadline, use_container_width=True)


def build_board_summary(df: pd.DataFrame) -> pd.DataFrame:
    rows = []

    for board_member, flag_col in BOARD_FLAG_COLUMNS.items():
        member_df = get_board_slice(df, board_member)
        if member_df.empty:
            rows.append(
                {
                    "Board Member": board_member,
                    "Total": 0,
                    "Overdue": 0,
                    "Due in 30 Days": 0,
                    "S4": 0,
                    "S3": 0,
                    "S2": 0,
                    "S1": 0,
                    "Median Days to Deadline": np.nan,
                }
            )
            continue

        severity_counts = member_df["Severity"].value_counts().to_dict()
        rows.append(
            {
                "Board Member": board_member,
                "Total": int(len(member_df)),
                "Overdue": int(member_df["Is Overdue"].sum()),
                "Due in 30 Days": int(member_df["Due in 30 Days"].sum()),
                "S4": int(severity_counts.get("S4", 0)),
                "S3": int(severity_counts.get("S3", 0)),
                "S2": int(severity_counts.get("S2", 0)),
                "S1": int(severity_counts.get("S1", 0)),
                "Median Days to Deadline": float(member_df["Days to Deadline"].median(skipna=True)),
            }
        )

    board_summary = pd.DataFrame(rows)
    return board_summary.sort_values("Total", ascending=False)


def render_board_insights(df: pd.DataFrame) -> None:
    summary = build_board_summary(df)
    if summary.empty:
        st.info("No board-specific assignments available for this sheet.")
        return

    st.dataframe(
        summary.set_index("Board Member"),
        use_container_width=True,
        column_config={
            "Median Days to Deadline": st.column_config.NumberColumn(format="%.0f"),
        },
    )

    melt_cols = ["S4", "S3", "S2", "S1"]
    if summary[melt_cols].to_numpy().sum() > 0:
        severity_long = summary.melt(
            id_vars="Board Member",
            value_vars=melt_cols,
            var_name="Severity",
            value_name="Count",
        )
        fig_heat = px.density_heatmap(
            severity_long,
            x="Severity",
            y="Board Member",
            z="Count",
            color_continuous_scale=["#e0f2fe", "#1d4ed8"],
            title="Severity Mix by Board Member",
        )
        fig_heat.update_traces(textfont=dict(color="#0f172a"))
        fig_heat.update_layout(
            margin=dict(t=50, r=40, b=40, l=80),
            paper_bgcolor="rgba(0,0,0,0)",
            plot_bgcolor="rgba(0,0,0,0)",
            font=dict(color="#0f172a"),
            coloraxis_colorbar=dict(title="Count"),
            title=dict(font=dict(color="#0f172a", size=18)),
        )
        fig_heat.update_xaxes(title_text="Severity", tickfont=dict(color="#0f172a"))
        fig_heat.update_yaxes(title_text="Board Member", tickfont=dict(color="#0f172a"))
        st.plotly_chart(fig_heat, use_container_width=True)

    if "Relevant Legal Entities" in df.columns:
        entity_counts = df[df["Relevant Legal Entities"].notna()].assign(
            **{"Relevant Legal Entities": lambda data: data["Relevant Legal Entities"].astype(str).str.split(",")}
        )
        entity_counts = entity_counts.explode("Relevant Legal Entities")
        entity_counts["Relevant Legal Entities"] = entity_counts["Relevant Legal Entities"].str.strip()
        top_entities = (
            entity_counts["Relevant Legal Entities"]
            .value_counts()
            .head(15)
            .rename_axis("Legal Entity")
            .reset_index(name="count")
        )
        if not top_entities.empty:
            fig_entities = px.bar(
                top_entities,
                x="count",
                y="Legal Entity",
                orientation="h",
                title="Top Impacted Legal Entities",
                text_auto=True,
                color="count",
                color_continuous_scale=["#22d3ee", "#6366f1"],
            )
            fig_entities.update_traces(textfont=dict(color="#0f172a"))
            fig_entities.update_layout(
                margin=dict(t=50, r=40, b=40, l=120),
                paper_bgcolor="rgba(0,0,0,0)",
                plot_bgcolor="rgba(0,0,0,0)",
                font=dict(color="#0f172a"),
                title=dict(font=dict(color="#0f172a", size=18)),
            )
            fig_entities.update_xaxes(title_text="Recommendations", tickfont=dict(color="#0f172a"))
            fig_entities.update_yaxes(title_text="Legal Entity", tickfont=dict(color="#0f172a"))
            st.plotly_chart(fig_entities, use_container_width=True)

def render_board_member_detail(df: pd.DataFrame, board_member: str, *, show_charts: bool = False) -> None:
    member_df = get_board_slice(df, board_member)

    if member_df.empty:
        st.info(f"No recommendations for {board_member} with the current filters.")
        return

    assignments = int(len(member_df))
    overdue = int(member_df["Is Overdue"].sum()) if "Is Overdue" in member_df.columns else 0
    due_soon = int(member_df["Due in 30 Days"].sum()) if "Due in 30 Days" in member_df.columns else 0
    median_days = float(member_df["Days to Deadline"].median(skipna=True)) if "Days to Deadline" in member_df.columns else np.nan

    col1, col2, col3, col4 = st.columns(4)
    col1.metric("Assignments", assignments)
    col2.metric("Overdue", overdue)
    col3.metric("Due in 30 Days", due_soon)
    col4.metric("Median Days to Deadline", f"{median_days:.0f}" if not np.isnan(median_days) else "‚Äî")

    if show_charts:
        st.markdown("##### Severity & Status Mix")
        render_distribution_charts(member_df)

    if "Current Deadline" in member_df.columns and member_df["Current Deadline"].notna().any():
        upcoming = (
            member_df.dropna(subset=["Current Deadline"])
            .sort_values("Current Deadline")
            .loc[:, [
                "Recommendation ID",
                "Current Deadline",
                "Severity",
                "Recommendation Status",
                "Recommendation Owner - Legal Entity",
            ]]
            .head(8)
        )
        if not upcoming.empty:
            st.markdown("##### Next Deadlines")
            st.dataframe(upcoming, use_container_width=True, hide_index=True)

    csv = member_df.to_csv(index=False).encode("utf-8")
    st.download_button(
        label=f"Download {board_member} data (CSV)",
        data=csv,
        file_name=f"exco_{board_member.replace('.', '').replace(' ', '_').lower()}_filtered.csv",
        mime="text/csv",
        use_container_width=True,
        key=f"download_{board_member.replace(' ', '_')}",
    )


def render_board_persona_panel(df: pd.DataFrame, persona: str) -> None:
    member_df = get_board_slice(df, persona)
    st.subheader(f"{persona} assignments")

    if member_df.empty:
        st.info("No recommendations available for this board member with the current filters.")
        return

    render_board_member_detail(df, persona, show_charts=True)

    st.markdown("##### Detailed View")
    render_data_table(member_df, show_download=False)


def render_data_table(df: pd.DataFrame, *, show_download: bool = True) -> None:
    if df.empty:
        st.warning("No recommendations match the current filter selection.")
        return

    preferred_order = [
        "Recommendation ID",
        "Finding Title",
        "Recommendation Status",
        "Severity",
        "Recommendation Owner - Legal Entity",
        "Board member",
        "Current Deadline",
        "Days to Deadline",
        "Due in 30 Days",
        "Is Overdue",
        "Relevant Legal Entities",
    ]

    available_cols = [col for col in preferred_order if col in df.columns]
    fallback_cols = [col for col in df.columns if col not in available_cols]
    display_cols = available_cols + fallback_cols

    table_df = df.copy()

    for date_col in [c for c in DATE_COLUMNS if c in table_df.columns]:
        table_df[date_col] = pd.to_datetime(table_df[date_col], errors="coerce")
        table_df[date_col] = table_df[date_col].dt.strftime("%d %b %Y")

    for boolean_col in ["Is Overdue", "Due in 30 Days"]:
        if boolean_col in table_df.columns:
            table_df[boolean_col] = table_df[boolean_col].apply(lambda x: "Yes" if bool(x) else "No")

    if "Days to Deadline" in table_df.columns:
        table_df["Days to Deadline"] = table_df["Days to Deadline"].apply(
            lambda x: f"{int(x)}" if pd.notna(x) else "‚Äî"
        )

    display_df = table_df[display_cols]

    def highlight_row(row: pd.Series) -> List[str]:
        overdue = row.get("Is Overdue", "No") == "Yes"
        due_soon = row.get("Due in 30 Days", "No") == "Yes"
        if overdue:
            return ["background-color: rgba(248, 113, 113, 0.25);"] * len(row)
        if due_soon:
            return ["background-color: rgba(251, 191, 36, 0.2);"] * len(row)
        return ["background-color: rgba(255, 255, 255, 0);"] * len(row)

    styled = display_df.style.apply(highlight_row, axis=1).format(na_rep="‚Äî").hide(axis="index")

    st.dataframe(styled, use_container_width=True)

    if show_download:
        csv = df.to_csv(index=False).encode("utf-8")
        st.download_button(
            label="Download filtered data (CSV)",
            data=csv,
            file_name="exco_recommendations_filtered.csv",
            mime="text/csv",
            use_container_width=True,
        )


@st.dialog("Missing Data File")
def show_missing_file_dialog() -> None:
    st.error(
        f"Could not find `{DATA_FILE}`.\n\n"
        "Generate the Excel output first by running `process_exco_report.py` "
        "or update `DATA_FILE` to point to the correct location."
    )
    st.stop()


def main() -> None:
    available_sheets = get_available_sheets()
    if not available_sheets:
        show_missing_file_dialog()

    apply_global_styles()

    with st.sidebar:
        st.header("Filters")
        selected_sheet = st.selectbox(
            "Source sheet",
            options=[sheet for sheet in available_sheets if not sheet.startswith("~$")],
            index=available_sheets.index(PRIMARY_SHEET) if PRIMARY_SHEET in available_sheets else 0,
        )

    df = load_sheet(selected_sheet)

    with st.sidebar:
        with st.expander("Filters", expanded=True):
            col_left, col_right = st.columns(2)

            with col_left:
                board_selection = st.multiselect(
                    "Board member",
                    options=BOARD_MEMBERS,
                    help="Limit analytics to specific board members.",
                )
                severity_options = [
                    sev
                    for sev in ["S4", "S3", "S2", "S1"]
                    if "Severity" in df.columns and df["Severity"].isin([sev]).any()
                ]
                severity_selection = st.multiselect(
                    "Severity",
                    severity_options,
                    default=severity_options,
                )
                st.caption("Tip: hold Cmd/Ctrl to select multiple severities.")

            with col_right:
                status_options = (
                    sorted(df["Recommendation Status"].dropna().unique())
                    if "Recommendation Status" in df.columns
                    else []
                )
                status_selection = st.multiselect("Status", status_options, default=status_options)

                legal_entity_options: List[str] = []
                if "Relevant Legal Entities" in df.columns:
                    all_entities = (
                        df["Relevant Legal Entities"]
                        .dropna()
                        .astype(str)
                        .str.split(",")
                        .explode()
                        .str.strip()
                        .unique()
                    )
                    legal_entity_options = sorted(entity for entity in all_entities if entity)
                legal_selection = st.multiselect("Legal entity", legal_entity_options)

            include_overdue_only = st.toggle("Show overdue only", value=False)
            include_due_soon_only = st.toggle("Show items due in next 30 days only", value=False)

            deadline_window: Optional[Tuple[date, date]] = None
            if "Current Deadline" in df.columns and df["Current Deadline"].notna().any():
                min_date = df["Current Deadline"].min().date()
                max_date = df["Current Deadline"].max().date()
                deadline_window = st.date_input(
                    "Deadline window",
                    value=(min_date, max_date),
                    min_value=min_date,
                    max_value=max_date,
                )

            search_text = st.text_input("Search (ID, title, description)")

        if DATA_FILE.exists():
            with DATA_FILE.open("rb") as fh:
                st.download_button(
                    label="Download full EXCO workbook",
                    data=fh.read(),
                    file_name=DATA_FILE.name,
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    use_container_width=True,
                )

    shared_filter_df = apply_filters(
        df=df,
        board_selection=[],
        severities=severity_selection,
        statuses=status_selection,
        legal_entities=legal_selection,
        include_overdue_only=include_overdue_only,
        include_due_soon_only=include_due_soon_only,
        deadline_window=deadline_window,
        search_text=search_text,
    )

    filtered_df = apply_filters(
        df=df,
        board_selection=board_selection,
        severities=severity_selection,
        statuses=status_selection,
        legal_entities=legal_selection,
        include_overdue_only=include_overdue_only,
        include_due_soon_only=include_due_soon_only,
        deadline_window=deadline_window,
        search_text=search_text,
    )

    render_header(df, selected_sheet)

    tab_titles = ["Overview", "Board Insights", "Data Explorer"]
    board_tab_titles = [f"{member} Board" for member in BOARD_MEMBERS]
    tabs = st.tabs(tab_titles + board_tab_titles)

    tab_overview = tabs[0]
    tab_board = tabs[1]
    tab_data = tabs[2]

    with tab_overview:
        render_kpis(filtered_df)
        render_distribution_charts(filtered_df)

    with tab_board:
        render_board_insights(shared_filter_df)

    with tab_data:
        st.markdown("### Recommendation Detail")
        render_data_table(filtered_df)

    for board_member, tab in zip(BOARD_MEMBERS, tabs[len(tab_titles):]):
        with tab:
            render_board_persona_panel(shared_filter_df, board_member)


if __name__ == "__main__":
    main()

